#!/usr/bin/env perl
BEGIN {$^W=1}

## (C) 2020-2021 Mindaugas Margelevicius, Institute of Biotechnology, Vilnius University
## Wrapper for conducting COMER search given input sequences or MSAs: from sequences
## to profile-profile alignments

use strict;
use Config;
use threads;
use threads::shared;
use FindBin;
use lib "$FindBin::Bin";
use readcfg;
use readopt;
use File::Spec;
use File::Basename;
use Getopt::Long;
use POSIX qw(strftime);

##constants:
my  $MYPROGNAME = basename($0);
my  $HHBLITShelper = File::Spec->catfile($FindBin::Bin,"hhblits_helper.sh");
my  $HMMERhelper = File::Spec->catfile($FindBin::Bin,"hmmsearch_iterated.sh");
my  $PWFA2MSAprog = File::Spec->catfile($FindBin::Bin,"pwfa2msa.pl");
my  $SENDMAILprog = File::Spec->catfile($FindBin::Bin,"sendemail.pl");
my  $CFGFILE = File::Spec->catfile($FindBin::Bin,File::Spec->updir(),"var","comer-ws-backend.conf");
my  $devnull = File::Spec->devnull();
my  $TARPROG = `which tar 2>$devnull`; chomp($TARPROG);
my  $GZPROG = `which gzip 2>$devnull`; chomp($GZPROG);
my  $MAXNCPUs = 6;##maximum number of CPU cores assigned for a job
##threshold for the number of queries which, if exceeded, implies creating threads, each assigned 1 cpu:
##(use a large number for serialization with multiple cores)
my  $MAXNQUERIES_multicore = 6;
##maximum number of sequences per search program permitted to be included in the results
my  $MAXNSEQS_perprog = 20000;
my  $MAXNQUERIES = 100;##maximum number of queries allowed in the input

my ($QRYEXT, $FASEXT, $AFAEXT, $STOEXT, $A3MEXT, $PWFEXT, $PROEXT, $DBEXT, $OUTEXT) = 
   ('qry','fa','afa','sto','a3m','pwfa','pro','bin','json');

my  $usage = <<EOIN;

Wrapper for conducting COMER search given input sequence(s) or MSA(s). It
connects all logic from sequences to profile-profile alignments.
(C)2020-2021 Mindaugas Margelevicius, Institute of Biotechnology, Vilnius University

Usage:
$0 <Options>

Options:

--in <input>     Input sequence(s) (plain or in FASTA) or MSAs in FASTA or 
                 STOCKHOLM format, used as the queries to search database(s).

--opt <options>  Filename of options for this job.

--status <file>  Name of the output status file of computation progress
                 messages.

--comerlog <logfile> Name of the output log file generated by the COMER
                 during a search.

--reslst <file>  Name of the output file listing the results files for the
                 queries.

--results <file> Name of the output compressed file containing the results
                 files for all queries. (Extension .gz will be added.)

--err <errfile>  Name of the file of high-level error messages to write to on
                 error.

--nopro          Do not construct COMER profile (implies --norun).
--norun          Do not run COMER.

--help           This help text.

EOIN


my  $INPFILENAME = '';
my  $OPTFILENAME = '';
my  $STAFILENAME = '';
my  $COMLOGFILENAME = '';
my  $RESLSTFILENAME = '';
my  $RESULTSFILENAME = '';
my  $ERRFILENAME = '';
my  $NOPRO = 0;
my  $NORUN = 0;
my  $Fail = 0;

my  $result = GetOptions(
               'in=s'       => \$INPFILENAME,
               'opt=s'      => \$OPTFILENAME,
               'status=s'   => \$STAFILENAME,
               'comerlog=s' => \$COMLOGFILENAME,
               'reslst=s'   => \$RESLSTFILENAME,
               'results=s'  => \$RESULTSFILENAME,
               'err=s'      => \$ERRFILENAME,
               'nopro'      => sub {$NOPRO=1;$NORUN=1;},
               'norun'      => \$NORUN,
               'help|h'     => sub {print $usage; exit(0);}
);

print(STDERR "\n\n".GetDatetime()."\n\n");

my ($inpbasename,$inpdirname,$suffix) = fileparse($INPFILENAME, qr/\.[^.]*/);
$inpdirname = File::Spec->rel2abs($inpdirname);

unless($STAFILENAME) {
    $STAFILENAME = File::Spec->catfile(${inpdirname},"${inpbasename}.status");
    print(STDERR "WARNING: $MYPROGNAME: Filename for computation progress mesages not given; ".
          "it has been set to: '$STAFILENAME'\n");
}
unless($NORUN) {
    unless($COMLOGFILENAME) {
        $COMLOGFILENAME = File::Spec->catfile(${inpdirname},"${inpbasename}__comer_out.log");
        print(STDERR "WARNING: $MYPROGNAME: Filename for COMER log mesages not given; ".
              "it has been set to: '$COMLOGFILENAME'\n");
    }
    unless($RESLSTFILENAME) {
        $RESLSTFILENAME = File::Spec->catfile(${inpdirname},"${inpbasename}__comer_out.lst");
        print(STDERR "WARNING: $MYPROGNAME: Filename for a results list not given; ".
              "it has been set to: '$RESLSTFILENAME'\n");
    }
    unless($RESULTSFILENAME) {
        $RESULTSFILENAME = File::Spec->catfile(${inpdirname},"${inpbasename}__comer_out.tar");
        print(STDERR "WARNING: $MYPROGNAME: Filename for compressed results not given; ".
              "it has been set to: '$RESULTSFILENAME'\n");
    }
}
unless($ERRFILENAME) {
    $ERRFILENAME = File::Spec->catfile(${inpdirname},"${inpbasename}.err");
    print(STDERR "WARNING: $MYPROGNAME: Filename for high-level error mesages not given; ".
          "it has been set to: '$ERRFILENAME'\n");
}
## truncate error file before using Error!
if(open(F,'>',$ERRFILENAME)){close(F);}
unless($result) {
    Error("ERROR: $MYPROGNAME: Error in command-line arguments.\n",
            "Command-line arguments error.\n");## h-l error message
    MyExit(1);
}
unless($INPFILENAME && -f $INPFILENAME) {
    Error("ERROR: $MYPROGNAME: Input file not found: '$INPFILENAME'\n",
            "Input file not found.\n");## h-l error message
    MyExit(1);
}
unless($OPTFILENAME && -f $OPTFILENAME) {
    Error("ERROR: $MYPROGNAME: Input job options file not found: '$OPTFILENAME'\n",
            "Job options file not found.\n");## h-l error message
    MyExit(1);
}
unless(-f $CFGFILE) {
    Error("ERROR: $MYPROGNAME: Config file not found: '$CFGFILE'\n",
            "Configuration file not found.\n");## h-l error message
    MyExit(1);
}
unless(-f $HHBLITShelper) {
    Error("ERROR: $MYPROGNAME: Program file not found: '$HHBLITShelper'\n",
            "Some of the required program files not found.\n");## h-l error message
    MyExit(1);
}
unless(-f $HMMERhelper) {
    Error("ERROR: $MYPROGNAME: Program file not found: '$HMMERhelper'\n",
            "Some of the required program files not found.\n");## h-l error message
    MyExit(1);
}
unless(-f $PWFA2MSAprog) {
    Error("ERROR: $MYPROGNAME: Program file not found: '$PWFA2MSAprog'\n",
            "Some of the required program files not found.\n");## h-l error message
    MyExit(1);
}
unless($TARPROG && $GZPROG) {
    Error("ERROR: $MYPROGNAME: System programs 'tar' and/or 'gzip' not found.\n",
            "Some of the system programs not found.\n");## h-l error message
    MyExit(1);
}


## =============================================================================

my  $cfgvar = readcfg->new($CFGFILE);
my  %optionvalues;

if($cfgvar->JobMaxNoQueries() < 1) {
    print(STDERR "WARNING: $MYPROGNAME: Maximum number of queries not given; ".
          "it has been set to: '$MAXNQUERIES'\n");
} else {
    $MAXNQUERIES = $cfgvar->JobMaxNoQueries();
}

unless(-d $cfgvar->PathSeqDb_UniRef()) {
    Error("ERROR: $MYPROGNAME: Database directory not found: '".$cfgvar->PathSeqDb_UniRef()."'\n",
            "Some of the database directories not found.\n");## h-l error message
    MyExit(1);
}
unless(-d $cfgvar->PathSeqDb_UniRefHHS()) {
    Error("ERROR: $MYPROGNAME: Database directory not found: '".$cfgvar->PathSeqDb_UniRefHHS()."'\n",
            "Some of the database directories not found.\n");## h-l error message
    MyExit(1);
}

unless(-d $cfgvar->PathComerDb_PDB()) {
    Error("ERROR: $MYPROGNAME: Database directory not found: '".$cfgvar->PathComerDb_PDB()."'\n",
            "Some of the database directories not found.\n");## h-l error message
    MyExit(1);
}
unless(-d $cfgvar->PathComerDb_SCOP()) {
    Error("ERROR: $MYPROGNAME: Database directory not found: '".$cfgvar->PathComerDb_SCOP()."'\n",
            "Some of the database directories not found.\n");## h-l error message
    MyExit(1);
}
unless(-d $cfgvar->PathComerDb_PFAM()) {
    Error("ERROR: $MYPROGNAME: Database directory not found: '".$cfgvar->PathComerDb_PFAM()."'\n",
            "Some of the database directories not found.\n");## h-l error message
    MyExit(1);
}


unless($NOPRO && $NORUN) {
    unless(-d $cfgvar->InstallDir_COMER()) {
        Error("ERROR: $MYPROGNAME: COMER installation directory not found: '".$cfgvar->InstallDir_COMER()."'\n",
            "Some of the installation directories not found.\n");## h-l error message
        MyExit(1);
    }
    unless(-d $cfgvar->InstallDir_BLAST()) {
        Error("ERROR: $MYPROGNAME: BLAST installation directory not found: '".$cfgvar->InstallDir_BLAST()."'\n",
            "Some of the installation directories not found.\n");## h-l error message
        MyExit(1);
    }
    unless(-d $cfgvar->InstallDir_PSIPRED()) {
        Error("ERROR: $MYPROGNAME: PSIPRED installation directory not found: '".$cfgvar->InstallDir_PSIPRED()."'\n",
            "Some of the installation directories not found.\n");## h-l error message
        MyExit(1);
    }
}
unless(-d $cfgvar->InstallDir_HHsuite()) {
    Error("ERROR: $MYPROGNAME: HHsuite installation directory not found: '".$cfgvar->InstallDir_HHsuite()."'\n",
            "Some of the installation directories not found.\n");## h-l error message
    MyExit(1);
}
unless(-d $cfgvar->InstallDir_HMMER()) {
    Error("ERROR: $MYPROGNAME: HMMER installation directory not found: '".$cfgvar->InstallDir_HMMER()."'\n",
            "Some of the installation directories not found.\n");## h-l error message
    MyExit(1);
}
#unless(-d $cfgvar->InstallDir_MODPLUS()) {
#    Error("ERROR: $MYPROGNAME: ModPlus installation directory not found: '".$cfgvar->InstallDir_MODPLUS()."'\n",
#            "Some of the installation directories not found.\n");## h-l error message
#    MyExit(1);
#}


##check particular programs
$optionvalues{prog_comer_comer} = '';
$optionvalues{prog_comer_makepro} = '';

unless($NOPRO && $NORUN) {
    $optionvalues{prog_comer_comer} = File::Spec->catfile($cfgvar->InstallDir_COMER(),'bin','comer');
    $optionvalues{prog_comer_makepro} = File::Spec->catfile($cfgvar->InstallDir_COMER(),'bin','makepro.sh');
    unless(-f $optionvalues{prog_comer_comer}) {
        Error("ERROR: $MYPROGNAME: COMER executable not found: '".$optionvalues{prog_comer_comer}."'\n",
            "Incomplete software installed on the system.\n");## h-l error message
        MyExit(1);
    }
    unless(-f $optionvalues{prog_comer_makepro}) {
        Error("ERROR: $MYPROGNAME: COMER executable not found: '".$optionvalues{prog_comer_makepro}."'\n",
            "Incomplete software installed on the system.\n");## h-l error message
        MyExit(1);
    }
}

$optionvalues{prog_hhsuite_hhblits} = File::Spec->catfile($cfgvar->InstallDir_HHsuite(),'bin','hhblits');
$optionvalues{prog_hhsuite_reformat} = File::Spec->catfile($cfgvar->InstallDir_HHsuite(),'scripts','reformat.pl');
unless(-f $optionvalues{prog_hhsuite_hhblits}) {
    Error("ERROR: $MYPROGNAME: HHsuite executable not found: '".$optionvalues{prog_hhsuite_hhblits}."'\n",
        "Incomplete software installed on the system.\n");## h-l error message
    MyExit(1);
}
unless(-f $optionvalues{prog_hhsuite_reformat}) {
    Error("ERROR: $MYPROGNAME: HHsuite executable not found: '".$optionvalues{prog_hhsuite_reformat}."'\n",
        "Incomplete software installed on the system.\n");## h-l error message
    MyExit(1);
}

$optionvalues{prog_hmmer_jackhmmer} = File::Spec->catfile($cfgvar->InstallDir_HMMER(),'bin','jackhmmer');
$optionvalues{prog_hmmer_hmmsearch} = File::Spec->catfile($cfgvar->InstallDir_HMMER(),'bin','hmmsearch');
$optionvalues{prog_hmmer_hmmbuild} = File::Spec->catfile($cfgvar->InstallDir_HMMER(),'bin','hmmbuild');
unless(-f $optionvalues{prog_hmmer_jackhmmer}) {
    Error("ERROR: $MYPROGNAME: HMMER executable not found: '".$optionvalues{prog_hmmer_jackhmmer}."'\n",
        "Incomplete software installed on the system.\n");## h-l error message
    MyExit(1);
}
unless(-f $optionvalues{prog_hmmer_hmmsearch}) {
    Error("ERROR: $MYPROGNAME: HMMER executable not found: '".$optionvalues{prog_hmmer_hmmsearch}."'\n",
        "Incomplete software installed on the system.\n");## h-l error message
    MyExit(1);
}
unless(-f $optionvalues{prog_hmmer_hmmbuild}) {
    Error("ERROR: $MYPROGNAME: HMMER executable not found: '".$optionvalues{prog_hmmer_hmmbuild}."'\n",
        "Incomplete software installed on the system.\n");## h-l error message
    MyExit(1);
}

## =============================================================================
## MAIN
##

my  $options = readopt->new($OPTFILENAME);
my  %optionkeys = (
    job_num_cpus => 'JOB_NUM_CPUS',
    comer_db => 'comer_db',
    sequence_db => 'sequence_db',
    hhsuite_db => 'hhsuite_db',

    hhsuite_in_use => 'hhsuite_in_use',
    hhsuite_opt_niterations => 'hhsuite_opt_niterations',
    hhsuite_opt_evalue => 'hhsuite_opt_evalue',

    hmmer_in_use => 'hmmer_in_use',
    hmmer_opt_niterations => 'hmmer_opt_niterations',
    hmmer_opt_evalue => 'hmmer_opt_evalue'
);
my  $nsyscpus = GetNCPUs();
my  $ncpus = $MAXNCPUs;

my  $infmsg = '';##info message
my  $errmsg = "ERROR: $MYPROGNAME: Invalid job options.\n";
my  $hlerrmsg = "Invalid job options.\n";

unless(VerifyOptionValues($cfgvar, $options, $NOPRO, $NORUN,
        \%optionkeys, \%optionvalues, \$errmsg, \$hlerrmsg)) {
    Error($errmsg, $hlerrmsg);## err msg and h-l error message
    MyExit(1);
}

if($Config{useithreads}) {
    if($cfgvar->Exists($optionkeys{job_num_cpus})) {
        $ncpus = $cfgvar->GetValue($optionkeys{job_num_cpus});
        $ncpus = $nsyscpus if($nsyscpus > 0 && $nsyscpus < $ncpus);
    }
    else {
        print(STDERR "WARNING: Job option $optionkeys{job_num_cpus} not specified: ".
            "Using default #cpus=${ncpus}\n");
    }
}
else {
    $ncpus = 1;
    print(STDERR "WARNING: Perl compiled WITHOUT thread support: ".
        "Using only one cpu: #cpus=${ncpus}\n");
}

my  $nqueries = 0;## :shared = 0;##number of individual queries/inputs
my  %inputs;## :shared;##all inputs divided

$errmsg = "ERROR: $MYPROGNAME: Distribution of the input to subdirs failed.\n";
$hlerrmsg = "Parsing or distribution of the input failed.\n";

ProgressMsg("Preparing input...\n");

unless(DistrInputToSubdirs(
        $INPFILENAME, $OPTFILENAME, $MAXNQUERIES,
        $inpdirname, $inpbasename, \$nqueries, \%inputs,
        \$infmsg, \$errmsg, \$hlerrmsg)) {
    Error($errmsg, $hlerrmsg);## err msg and h-l error message
    MyExit(1);
}

ProgressMsg("$infmsg\n") if $infmsg;

$errmsg = '';
$hlerrmsg = '';
my $oneworker;

if($optionvalues{$optionkeys{hhsuite_in_use}}) {
    ProgressMsg("Searching sequences for MSAs...\n");

    unless(RunThreadsAndWait(\&ProcessQuery_hhsuite_t, $oneworker=1, 
            $NOPRO, $NORUN, $ncpus, $nqueries, \%inputs,
            \%optionkeys, \%optionvalues, \$errmsg, \$hlerrmsg)) {
        Error($errmsg);## err msg and h-l error message
        ##continue on...
    }
}

$errmsg = '';
$hlerrmsg = '';

ProgressMsg("Buiding MSAs by sequence search and constructing profiles...\n");

unless(RunThreadsAndWait(\&ProcessQuery_t, $oneworker=0, 
        $NOPRO, $NORUN, $ncpus, $nqueries, \%inputs,
        \%optionkeys, \%optionvalues, \$errmsg, \$hlerrmsg)) {
    Error($errmsg);## err msg and h-l error message
    ##continue on...
}

unless($NORUN) {

    ProgressMsg("Searching by profile-profile alignment using COMER...\n");

    unless(RunCOMER($inpdirname, $inpbasename, $COMLOGFILENAME, $nqueries,
        \%inputs, \%optionkeys, \%optionvalues, \$errmsg, \$hlerrmsg)) { 
        Error($errmsg, $hlerrmsg);
        MyExit(1);
    }

    ProgressMsg("Finalizing results...\n");

    my  @resfilelist;

    unless(MakeResultsList(\@resfilelist, $inpdirname, $RESLSTFILENAME, $nqueries,
        \%inputs, \$errmsg, \$hlerrmsg)) {
        Error($errmsg, $hlerrmsg);
        MyExit(1);
    }

    unless(CompressResults($TARPROG, $GZPROG, $inpdirname, $RESULTSFILENAME, 
        \@resfilelist, 
        $COMLOGFILENAME, $RESLSTFILENAME, $STAFILENAME, $ERRFILENAME,
        \$errmsg, \$hlerrmsg)) {
        Error($errmsg, $hlerrmsg);
        MyExit(1);
    }
}

ProgressMsg("Finished.\n");

MyExit(0);

## =============================================================================
## -----------------------------------------------------------------------------
## GetTime: get time string
##
sub GetTime
{
    return strftime("%H:%M:%S ",localtime());
}

sub GetDatetime
{
    return strftime("%a %b %d %H:%M:%S %Z %Y",localtime());
}

## -----------------------------------------------------------------------------
## GetNCPUs: get the number of CPU cores in the system; return <0 on error;
##
sub GetNCPUs
{
    unless(open(H, "/proc/cpuinfo")) {
        print(STDERR "WARNING: Unable to determine #cpu cores.\n");
        return -1;##failed to open cpuinfo: $!
    }
    my $ncpus = scalar(grep(/^processor/,<H>)); 
    close(H);
    return $ncpus;
}

## -----------------------------------------------------------------------------
## ProgressMsg: Print progress message to file
##
sub ProgressMsg
{
    my  $msg = shift;
    return 0 unless(open(F,'>>',$STAFILENAME));
    print(F $msg);
    close(F);
    return 1;
}

## -----------------------------------------------------------------------------
## GetWarnings: extract warnings from a log file
##
sub GetWarnings
{
    my  $comerlogfile = shift;##comer search log file
    my  $rlist = shift;##ref to the output list of warnings
    unless(open(F, $comerlogfile)) {
        print(STDERR "WARNING: Unable to open COMER log file: '$comerlogfile'.\n");
        return 0;
    }
    @$rlist = grep(/\sWARNING/,<F>);
    close(F);
    return 1;
}

## -----------------------------------------------------------------------------
## ChangeProfileFileField: change the FILE field of a COMER profile
##
sub ChangeProfileFileField
{
    my  $profile = shift;##comer profile
    my  $outprofile = shift;##output comer profile
    my  $fieldvalue = shift;##new value of the FILE field
    my  $procontents = '';
    unless(open(F, $profile)) {
        print(STDERR "ERROR: ChangeProfileFileField: Failed to open file: '$profile'.\n\n");
        return 0;
    }
    while(<F>) {
        s/^(FILE:).*$/$1 $fieldvalue/;
        $procontents .= $_;
    }
    close(F);
    unless(open(F, '>', $outprofile)) {
        print(STDERR "ERROR: ChangeProfileFileField: Failed to open file for writing: '$profile'.\n\n");
        return 0;
    }
    print F $procontents;
    close(F);
    return 1;
}

## -----------------------------------------------------------------------------
## AddFileToArchive: add a file to a given archive
##
sub AddFileToArchive
{
    my  $tarprog = shift;##full pathname to the tar program
    my  $archive = shift;##fullname of the resulting archive file
    my  $filepathname = shift;##full pathname to the file
    my  $dirname = shift;##name of directory where $filepathname is; may be empty
    my  $rerrmsg = shift;##ref to the error message string to be put in logs
    my  $rhlerrmsg = shift;##ref to the h-l error message string
    my  $create = shift;##flag of whether the archive is to be created

    my  $mysubname = (caller(0))[3];
    my  $preamb = "[ ${mysubname} ] ";
    my  $command = '';
    my  $opt = $create?'c':'r';
    my  $ret = 1;

    if($dirname) {
        $command = "${tarprog} -${opt}f \"${archive}\" -C \"$dirname\" \"${filepathname}\"";
    }
    else {
        my $filedirname = dirname($filepathname);
        my $filename = basename($filepathname);
        $command = "${tarprog} -${opt}f \"${archive}\" -C \"${filedirname}\" \"${filename}\"";
    }

    print(STDERR GetTime()."${preamb} ${command}\n");

    unless(ExecCommand($command)) {
        $$rerrmsg = "ERROR: $MYPROGNAME: $mysubname: Failed to add file to archive: '${filepathname}'\n";
        $$rhlerrmsg = "Failed to archive some of the results files.\n";
        return 0;
    }

    return $ret;
}

## -----------------------------------------------------------------------------
## VerifyOptionValues: verify directory and filename information given in the 
## job options file
##
sub VerifyOptionValues 
{
    my  $cfgobj = shift;##backend configuration object
    my  $optobj = shift;##options object
    my  $nopro = shift;##flag of no construction of COMER profiles
    my  $norun = shift;##flag of no COMER run
    my  $roptionkeys = shift;##ref to the keys of options
    my  $roptionvalues = shift;## ref to the values of options
    my  $rerrmsg = shift;##ref to the error message string
    my  $rhlerrmsg = shift;##ref to the h-l error message string

    my  $mysubname = (caller(0))[3];
    my ($filename, $fullname, $fullnameext);
    my  $ret = 1;


    unless($norun) {
        unless($optobj->Exists($$roptionkeys{comer_db})) {
            $$rerrmsg = "ERROR: $MYPROGNAME: $mysubname: ".
                "Option $$roptionkeys{comer_db} not specified in the job options file.\n";
            $$rhlerrmsg = "COMER profile database not specified.\n";
            return 0;
        }

        $$roptionvalues{$$roptionkeys{comer_db}} = '';
        $filename = $optobj->GetValue($$roptionkeys{comer_db});
        my @fnames = split(',', $filename);
        my @fullnamelist;
        foreach $filename(@fnames) {
            $fullname = File::Spec->catfile($cfgobj->PathComerDb_PDB(),${filename});
            $fullnameext = "${fullname}.${DBEXT}";

            if(-f $fullnameext) {
                push @fullnamelist, $fullname;
            } else {
                $fullname = File::Spec->catfile($cfgobj->PathComerDb_SCOP(),${filename});
                $fullnameext = "${fullname}.${DBEXT}";
                if(-f $fullnameext) {
                    push @fullnamelist, $fullname;
                } else {
                    $fullname = File::Spec->catfile($cfgobj->PathComerDb_PFAM(),${filename});
                    $fullnameext = "${fullname}.${DBEXT}";
                    if(-f $fullnameext) {
                        push @fullnamelist, $fullname;
                    } else {
                        my $text = "WARNING: COMER profile database not found: $filename\n";
                        Warning($text, $text, 1);##no e-mail
                    }
                }
            }
        }

        if($#fullnamelist < 0) {
            $$rerrmsg = "ERROR: $MYPROGNAME: $mysubname: ".
              "All COMER db(s) '${filename}' not found in the COMER db directories.\n";
            $$rhlerrmsg = "COMER profile database(s) not found.\n";
            return 0;
        }

        $$roptionvalues{$$roptionkeys{comer_db}} = join(',',@fullnamelist);
    }


    $$roptionvalues{$$roptionkeys{hhsuite_in_use}} = 
        ($optobj->Exists($$roptionkeys{hhsuite_in_use})? 
            $optobj->GetValue($$roptionkeys{hhsuite_in_use}): 0);

    if($$roptionvalues{$$roptionkeys{hhsuite_in_use}}) {
        if(!$optobj->Exists($$roptionkeys{hhsuite_opt_niterations}) || 
            $optobj->GetValue($$roptionkeys{hhsuite_opt_niterations}) !~ /^0*[1-9]\d*\s*/)
        {
            $$rerrmsg = "ERROR: $MYPROGNAME: $mysubname: ".
                "Option $$roptionkeys{hhsuite_opt_niterations} either undefined or invalid.\n";
            $$rhlerrmsg = "A job option, number of iterations, is invalid.\n";
            return 0;
        }

        $$roptionvalues{$$roptionkeys{hhsuite_opt_niterations}} = 
            $optobj->GetValue($$roptionkeys{hhsuite_opt_niterations});

        if(!$optobj->Exists($$roptionkeys{hhsuite_opt_evalue}) || 
            $optobj->GetValue($$roptionkeys{hhsuite_opt_evalue}) !~ /^\d*\.?\d*(?:e[\+\-])?\d+\s*/)
        {
            $$rerrmsg = "ERROR: $MYPROGNAME: $mysubname: ".
                "Option $$roptionkeys{hhsuite_opt_evalue} either undefined or invalid.\n";
            $$rhlerrmsg = "A job option, E-value, is invalid.\n";
            return 0;
        }

        $$roptionvalues{$$roptionkeys{hhsuite_opt_evalue}} =
            $optobj->GetValue($$roptionkeys{hhsuite_opt_evalue});

        unless($optobj->Exists($$roptionkeys{hhsuite_db})) {
            $$rerrmsg = "ERROR: $MYPROGNAME: $mysubname: ".
                "Option $$roptionkeys{hhsuite_db} not specified in the job options file.\n";
            $$rhlerrmsg = "HHsuite database not specified.\n";
            return 0;
        }
        
        $$roptionvalues{$$roptionkeys{hhsuite_db}} = '';
        $filename = $optobj->GetValue($$roptionkeys{hhsuite_db});
        $fullname = File::Spec->catfile($cfgobj->PathSeqDb_UniRefHHS(),$filename);
        
        if(scalar(glob("${fullname}*"))) {
            $$roptionvalues{$$roptionkeys{hhsuite_db}} = $fullname;
        }
        
        unless($$roptionvalues{$$roptionkeys{hhsuite_db}}) {
            $$rerrmsg = "ERROR: $MYPROGNAME: $mysubname: ".
                "HHsuite db '${filename}*' not found in all HHsuite db directories.\n";
            $$rhlerrmsg = "HHsuite database not found.\n";
            return 0;
        }
    }


    $$roptionvalues{$$roptionkeys{hmmer_in_use}} = 
        ($optobj->Exists($$roptionkeys{hmmer_in_use})? 
            $optobj->GetValue($$roptionkeys{hmmer_in_use}): 0);

    if($$roptionvalues{$$roptionkeys{hmmer_in_use}}) {
        if(!$optobj->Exists($$roptionkeys{hmmer_opt_niterations}) || 
            $optobj->GetValue($$roptionkeys{hmmer_opt_niterations}) !~ /^0*[1-9]\d*\s*/)
        {
            $$rerrmsg = "ERROR: $MYPROGNAME: $mysubname: ".
                "Option $$roptionkeys{hmmer_opt_niterations} either undefined or invalid.\n";
            $$rhlerrmsg = "A job option, number of iterations, is invalid.\n";
            return 0;
        }

        $$roptionvalues{$$roptionkeys{hmmer_opt_niterations}} = 
            $optobj->GetValue($$roptionkeys{hmmer_opt_niterations});

        if(!$optobj->Exists($$roptionkeys{hmmer_opt_evalue}) || 
            $optobj->GetValue($$roptionkeys{hmmer_opt_evalue}) !~ /^\d*\.?\d*(?:e[\+\-])?\d+\s*/)
        {
            $$rerrmsg = "ERROR: $MYPROGNAME: $mysubname: ".
                "Option $$roptionkeys{hmmer_opt_evalue} either undefined or invalid.\n";
            $$rhlerrmsg = "A job option, E-value, is invalid.\n";
            return 0;
        }

        $$roptionvalues{$$roptionkeys{hmmer_opt_evalue}} =
            $optobj->GetValue($$roptionkeys{hmmer_opt_evalue});

        unless($optobj->Exists($$roptionkeys{sequence_db})) {
            $$rerrmsg = "ERROR: $MYPROGNAME: $mysubname: ".
                "Option $$roptionkeys{sequence_db} not specified in the job options file.\n";
            $$rhlerrmsg = "A sequence database is not specified.\n";
            return 0;
        }
        
        $$roptionvalues{$$roptionkeys{sequence_db}} = '';
        $filename = $optobj->GetValue($$roptionkeys{sequence_db});
        $fullname = File::Spec->catfile($cfgobj->PathSeqDb_UniRef(),$filename);
        
        if(-f $fullname) {
            $$roptionvalues{$$roptionkeys{sequence_db}} = $fullname;
        }
        
        unless($$roptionvalues{$$roptionkeys{sequence_db}}) {
            $$rerrmsg = "ERROR: $MYPROGNAME: $mysubname: ".
                "Sequence db '${filename}' not found in all sequence db directories.\n";
            $$rhlerrmsg = "Sequence database not found.\n";
            return 0;
        }
    }

    return $ret;
}

## -----------------------------------------------------------------------------
## DistrInputToSubdirs: parse the input and distribute individual queries to 
## subdirectories;
##
sub DistrInputToSubdirs
{
    my  $inpfilename = shift;##the input to be parsed for multiple individual inputs
    my  $optfilename = shift;##the options file accompanying the input
    my  $maxnqueries = shift;##max number of queries allowed
    my  $dirname = shift;##name of directory where to create subdirectories
    my  $basename = shift;##name pattern for to-be-created files in subdirectories
    my  $rnqueries = shift;##ref to the number of queries
    my  $rinputs = shift;##ref to the hash of individual inputs
    my  $rinfmsg = shift;##ref to an information message
    my  $rerrmsg = shift;##ref to the error message string to be put in logs
    my  $rhlerrmsg = shift;##ref to the h-l error message string

    my  $mysubname = (caller(0))[3];
    my  $inputsep = qr/^\/\//;
    my ($ndescs) = (0);
    my ($qrycontents, $qrysubdir, $qrybasename, $qryfullname, $ext) = ('','','','','');
    my ($lastext, $seqn, $prevseqn) = ('','','');
    my  $ret = 1;

    unless(open(F, $inpfilename)) {
        $$rerrmsg = "ERROR: $MYPROGNAME: $mysubname: Failed to open the input file: '$inpfilename'\n";
        $$rhlerrmsg = "Input file not found.\n";
        return 0;
    }
    $$rnqueries = 0;
    while(<F>) {
        next if(!eof(F) && /^\s*$/);
        if(eof(F) || !/$inputsep/) {
            $ext = $STOEXT if(!$qrycontents && /^#\s+STOCKHOLM/);
            $ext = $PROEXT if(!$qrycontents && /^COMER\s+profile/);
            if(/^>(?:ss_dssp|ss_pred|ss_conf)/) {
                $ext = $A3MEXT;
            }
            $qrycontents .= $_ unless(/$inputsep/);
            $ndescs++ if(/^\s*>/);
            if(eof(F) || !/^\s*>/) {
                ##NOTE: $_ changes here
                chomp;
                s/^\s+(.+)\s+$/$1/;
                $seqn .= $_;
            }
        }
        if(eof(F) || /$inputsep/ || /^\s*>/) {
            $prevseqn = $seqn unless $prevseqn;
            if(!$ext && length($prevseqn) != length($seqn)) {
                $ext = $A3MEXT;
            }
            $seqn = '';
        }
        if(eof(F) || /$inputsep/) {
            next unless $qrycontents;
            if($maxnqueries <= $$rnqueries) {
                my $text = "\nWARNING: Number of queries ".
                    "reduced to the maximum allowed: $maxnqueries\n";
                Warning($text, $text, 1);##no e-mail
                last;
            }
            if($ext && $ext eq $STOEXT) {##STOCKHOLM format
                $qrycontents .= $_;
                $$rinfmsg = 'MSA STOCKHOLM format' unless $lastext;
            } elsif($ext && $ext eq $PROEXT) {##COMER profile
                $$rinfmsg = 'profile COMER format' unless $lastext;
            } elsif($ext && $ext eq $A3MEXT) {##A3M profile
                $$rinfmsg = 'MSA A3M format' unless $lastext;
            } elsif($ndescs < 1) {##assume a plain sequence: make FASTA
                $qrycontents = ">Query_${$rnqueries} (unnamed)\n".$qrycontents;
                $ext = $FASEXT;
                $$rinfmsg = 'sequence FASTA/plain format' unless $lastext;
            } elsif($ndescs == 1) {##sequence in FASTA
                $ext = $FASEXT;
                $$rinfmsg = 'sequence FASTA format' unless $lastext;
            } else {##MSA in FASTA
                $ext = $AFAEXT;
                $$rinfmsg = 'MSA aligned FASTA format' unless $lastext;
            }
            $lastext = $ext unless $lastext;
            $$rinfmsg = '  The queries in the input have different formats' if $lastext cmp $ext;
            $qrysubdir = File::Spec->catfile($dirname,"${basename}__${$rnqueries}");
            $qrybasename = File::Spec->catfile($qrysubdir,"${basename}__${$rnqueries}");
            $qryfullname = "${qrybasename}.${ext}";
            ;;
            unless( -d $qrysubdir || mkdir($qrysubdir)) {
                $$rerrmsg = "ERROR: $MYPROGNAME: $mysubname: Failed to create directory: '$qrysubdir'\n";
                $$rhlerrmsg = "Creating a directory failed.\n";
                $ret = 0;
                last;
            }
            unless(open(FIN, ">", $qryfullname)) {
                $$rerrmsg = "ERROR: $MYPROGNAME: $mysubname: Failed to open file for writing: '$qryfullname'\n";
                $$rhlerrmsg = "Failed to create a file.\n";
                $ret = 0;
                last;
            }
            unless(print(FIN $qrycontents)) {
                $$rerrmsg = "ERROR: $MYPROGNAME: $mysubname: Failed to write to file: '$qryfullname'\n";
                $$rhlerrmsg = "Write to a file failed.\n";
                close(FIN);
                $ret = 0;
                last;
            }
            close(FIN);
            $$rinputs{"${$rnqueries}_rcode"} = 0;
            $$rinputs{"${$rnqueries}_error"} = '';##error message
            $$rinputs{"${$rnqueries}_errhl"} = '';##high-level error message
            $$rinputs{"${$rnqueries}_isize"} = length($qrycontents);
            $$rinputs{"${$rnqueries}_input"} = $qryfullname;
            $$rinputs{"${$rnqueries}_bname"} = $qrybasename;
            $$rinputs{"${$rnqueries}_logfl"} = "${qrybasename}.log";
            $$rinputs{"${$rnqueries}_msafl"} = '';
            $$rinputs{"${$rnqueries}_profl"} = '';
            $$rinputs{"${$rnqueries}_outfl"} = '';
            $$rinputs{"${$rnqueries}_hhsrun"} = 0;##hhsuite has not been run
            $$rinputs{"${$rnqueries}_hmmrun"} = 0;##hmmer has not been run
            ;;
            $qrycontents = $qrysubdir = $qrybasename = $qryfullname = $ext = '';
            $seqn = $prevseqn = '';
            $ndescs = 0;
            $$rnqueries++;
            next;
        }
    }
    close(F);

    if($$rnqueries < 1) {
        $$rerrmsg = "ERROR: $MYPROGNAME: $mysubname: No queries found in the input.\n";
        $$rhlerrmsg = "Invalid input format: No queries.\n";
        return 0;
    }

    if($$rnqueries == 1) {
        $$rinfmsg =~ s/^(MSA|sequence)(.+)$/  The $1 is in$2/;
    } else {
        $$rinfmsg =~ s/^(MSA|sequence|profile)(.+)$/  The $1s in the input are all in$2/;
    }

    return $ret;
}

## -----------------------------------------------------------------------------
## RunCOMER: put all profiles together in one file and run COMER search
##
sub RunCOMER
{
    my  $dirname = shift;##name of the job directory
    my  $basename = shift;##basename of the (whole) input transfered to the backend
    my  $comerlogfile = shift;##fullname of the log file to be generated by COMER
    my  $nqueries = shift;##number of queries
    my  $rinputs = shift;##ref to the hash of individual inputs
    my  $roptionkeys = shift;##ref to the keys of options
    my  $roptionvalues = shift;## ref to the values of options
    my  $rerrmsg = shift;##ref to the error message string to be put in logs
    my  $rhlerrmsg = shift;##ref to the h-l error message string

    my  $mysubname = (caller(0))[3];
    my  $preamb = "[ ${mysubname} ] ";
    my  @qrynums = 0..$nqueries-1;
    my  $fileofprofiles = File::Spec->catfile($dirname,"${basename}__nqries${nqueries}.${PROEXT}");
    my  $outputpfx = File::Spec->catfile($dirname,"${basename}__comer_out");
    my  $outputsubdir = $outputpfx;
    my  $comeropt_pass2memp = 50;
    ##no. trials to launch comer; NOTE: may fail when two or more processes request resources at the same time:
    my  $ntrials = 3;
    my  $command = '';
    my  @warnings;
    my  $ret = 1;

    for(my $q = 0; $q <= $#qrynums; $q++) {
        my $qnum = $qrynums[$q];
        ##print errors issued by threads if any
        if($$rinputs{"${qnum}_rcode"}) { ##don't send an e-mail
            Error($$rinputs{"${qnum}_error"}, $$rinputs{"${qnum}_errhl"}, 1);
            next;
        }
        $command .= " \"".$$rinputs{"${qnum}_profl"}."\"";
    }

    unless($command) {
        $$rerrmsg = "ERROR: $MYPROGNAME: $mysubname: Making profiles for all queries failed.\n";
        $$rhlerrmsg = "Making profiles for all queries failed. Please check your input.\n";
        return 0;
    }

    ##put all profiles into one file
    $command = "cat ${command} >\"${fileofprofiles}\"";

    print(STDERR GetTime()."${preamb} ${command}\n\n");

    unless(ExecCommand($command)) {
        $$rerrmsg = "ERROR: $MYPROGNAME: $mysubname: Failed to combine profiles into one file\n";
        $$rhlerrmsg = "Combining profiles into one file failed.\n";
        return 0;
    }

    ##run comer
    my $gpumemopt = '';
    if($cfgvar->Exists('JOB_GPU_MEM')) {
        my $valuemb = $cfgvar->GetValue('JOB_GPU_MEM')*1024;
        $gpumemopt = "--dev-mem=${valuemb}" if $valuemb > 256;
    }
    $command = "$$roptionvalues{prog_comer_comer} ".
            "-v -i \"${fileofprofiles}\" -d \"".$$roptionvalues{$$roptionkeys{comer_db}}.
            "\" -o \"${outputsubdir}\" -p \"${OPTFILENAME}\" -f 1 ".
            "--dev-pass2memp=${comeropt_pass2memp} ${gpumemopt} >\"${comerlogfile}\" 2>&1";

    for(my $i=1;; $i++) {
        print(STDERR GetTime()."${preamb} ${command}\n\n");
        unless(ExecCommand($command)) {
            do{ sleep(2); next} if $i < $ntrials;
            $$rerrmsg = "ERROR: $MYPROGNAME: $mysubname: Unable to conduct a COMER search.\n";
            $$rhlerrmsg = "Unable to conduct a COMER search.\n";
            return 0;
        }
        last;
    }

    ##extract warnings if any; no check of return code
    GetWarnings($comerlogfile, \@warnings);

    if(0 <= $#warnings) {
        my $lst = join("", @warnings);
        my $text = "\nWarnings from the COMER search:\n\n$lst\n\n";
        Warning($text, $text, 1);##no e-mail
    }

    ##associate comer results with particular queries
    $command = '';
    for(my ($q,$c) = (0,0); $q <= $#qrynums; $q++) {
        my $qnum = $qrynums[$q];
        ##skip queries with pending errors and which have not been searched for
        next if($$rinputs{"${qnum}_rcode"});

        my $namepattern = "${outputsubdir}/".basename($$rinputs{"${qnum}_bname"})."*__${c}.${OUTEXT}";
        my @outfiles = glob($namepattern);
        if($#outfiles < 0) {
            $$rinputs{"${qnum}_rcode"} = 1;
            $$rinputs{"${qnum}_error"} = "ERROR: $MYPROGNAME: $mysubname: COMER results for query No.${qnum} not found.\n";
            $$rinputs{"${qnum}_errhl"} = "COMER results for query No.${qnum} not found.\n";
            Error($$rinputs{"${qnum}_error"}, $$rinputs{"${qnum}_errhl"}, 1);##no e-mail
        }
        else {
            $$rinputs{"${qnum}_outfl"} = $command = $outfiles[0];
        }
        $c++;
    }

    unless($command) {
        $$rerrmsg = "ERROR: $MYPROGNAME: $mysubname: No COMER results for all queries.\n";
        $$rhlerrmsg = "No COMER results for all queries.\n";
        return 0;
    }

    return $ret;
}

## -----------------------------------------------------------------------------
## MakeResultsList: make and write to a file the list of the results files over 
## all queries
##
sub MakeResultsList
{
    my  $rfilelist = shift;##ref to the list of files listed in the results list file
    my  $dirname = shift;##name of the job directory
    my  $reslstfile = shift;##name of the output results listing file to be generated
    my  $nqueries = shift;##number of queries
    my  $rinputs = shift;##ref to the hash of individual inputs
    my  $rerrmsg = shift;##ref to the error message string to be put in logs
    my  $rhlerrmsg = shift;##ref to the h-l error message string

    my  $mysubname = (caller(0))[3];
    my  $preamb = "[ ${mysubname} ] ";
    my  @qrynums = 0..$nqueries-1;
    my  $ret = 1;

    unless(open(F,'>',$reslstfile)){
        $$rerrmsg = "ERROR: $MYPROGNAME: $mysubname: Failed to open file for writing: '${reslstfile}'.\n";
        $$rhlerrmsg = "Opening file for writing failed.\n";
        return 0;
    }

    print(F "# COMER_results COMER_profile MSA Query\n");

    for(my $q = 0; $q <= $#qrynums; $q++) {
        my $qnum = $qrynums[$q];
        ##skip queries with pending errors
        next if($$rinputs{"${qnum}_rcode"});

        my @files = ( $$rinputs{"${qnum}_outfl"},
                      $$rinputs{"${qnum}_profl"},
                      $$rinputs{"${qnum}_msafl"},
                      $$rinputs{"${qnum}_input"}
        );

        $_ =~ s/^${dirname}\/*(.+)$/$1/ foreach @files;

        print(F "\"$files[0]\"\t\"$files[1]\"\t\"$files[2]\"\t\"$files[3]\"\n");

        push @$rfilelist, @files;
    }

    close(F);
    return $ret;
}

## -----------------------------------------------------------------------------
## CompressResults: compress all required results files to a single archive
##
sub CompressResults
{
    my  $tarprog = shift;##full pathname to the tar program
    my  $gzprog = shift;##full pathname to the gzip program
    my  $dirname = shift;##name of the job directory
    my  $resultsfile = shift;##name of the output results archive file to be created
    my  $rfilelist = shift;##ref to the list of ($dirname-prefix-removed) files to include in the archive
    my  $comerlogfile = shift;##fullname of the log file to include in the archive
    my  $reslstfile = shift;##fullname of the results listing file to include in the archive
    my  $statusfile = shift;##fullname of the status messages file to include in the archive
    my  $errorfile = shift;##fullname of the high-level error messages file to include in the archive
    my  $rerrmsg = shift;##ref to the error message string to be put in logs
    my  $rhlerrmsg = shift;##ref to the h-l error message string

    my  $mysubname = (caller(0))[3];
    my  $preamb = "[ ${mysubname} ] ";
    my  $command = '';
    my  $ret = 1;

    return 0 unless(AddFileToArchive($tarprog, 
        $resultsfile, $comerlogfile, '', $rerrmsg, $rhlerrmsg, 1)); #no dirname; 1==create

    return 0 unless(AddFileToArchive($tarprog, 
        $resultsfile, $reslstfile, '', $rerrmsg, $rhlerrmsg)); #no dirname

    for(my $i = 0; $i <= $#{$rfilelist}; $i++) {
        next unless $$rfilelist[$i];
        return 0 unless(AddFileToArchive($tarprog, 
            $resultsfile, $$rfilelist[$i], $dirname, $rerrmsg, $rhlerrmsg)); #dirname given
    }

    unless(AddFileToArchive($tarprog, 
        $resultsfile, $statusfile, '', $rerrmsg, $rhlerrmsg)){ #no dirname
        ##record an error, don't stop and  don't send an e-mail
        Error($$rerrmsg, $$rhlerrmsg, 1);
    }

    unless(AddFileToArchive($tarprog, 
        $resultsfile, $errorfile, '', $rerrmsg, $rhlerrmsg)){ #no dirname
        ##record an error, don't stop and  don't send an e-mail
        Error($$rerrmsg, $$rhlerrmsg, 1);
    }

    $command = "${gzprog} -f \"${resultsfile}\"";

    print(STDERR GetTime()."${preamb} ${command}\n\n");

    unless(ExecCommand($command)) {
        $$rerrmsg = "ERROR: $MYPROGNAME: $mysubname: Failed to gzip the archive: '${resultsfile}'\n";
        $$rhlerrmsg = "Failed to compress the archive of results files.\n";
        return 0;
    }

    return $ret;
}

## THREADS =====================================================================
##
## RunThreadsAndWait: launch threads for producing MSAs and making profiles, and 
## wait for them to finish
##
sub RunThreadsAndWait
{
    my  $subroutine_t = shift;##thread subroutine address
    my  $oneworker = shift;##flag instructing to use only one worker with spec. #cpus
    my  $nopro = shift;##flag of no construction of COMER profiles
    my  $norun = shift;##flag of no COMER run
    my  $ncpus = shift;##number of cpus
    my  $nqueries = shift;##number of queries
    my  $rinputs = shift;##ref to the hash of individual inputs
    my  $roptionkeys = shift;##ref to the keys of options
    my  $roptionvalues = shift;## ref to the values of options
    my  $rerrmsg = shift;##ref to the error message string to be put in logs
    my  $rhlerrmsg = shift;##ref to the h-l error message string

    my  $nworkers = 1;##number of threads
    my ($tmMSA, $tmPro, $procd) = (0,0,0);##timespans and fraction of processed queries
    ##query serial numbers sorted by query size:
    my  @qrynums = sort {$$rinputs{"${b}_isize"} <=> $$rinputs{"${a}_isize"}} 0..$nqueries-1;
    my  @workers;
    my  $ret = 1;

    if(!$oneworker && 
        $#qrynums+1 > $MAXNQUERIES_multicore)
    {
        $nworkers = $ncpus;
        $ncpus = 1;
    }

    printf(STDERR "\nINFO: #queries= %d  dedicated #workers= %d #cpus= %d/wrk.\n\n",
        $#qrynums+1,$nworkers,$ncpus);

    my @joinable = ();
    my ($nsuccess, $nqries, $nvalidqries) = (0,$#qrynums+1,$#qrynums+1);

    for(my $q = 0; $q <= $#qrynums || threads->list(threads::all); ) {
        my $w = threads->list(threads::running);
        for( ; $w < $nworkers && $q <= $#qrynums; $w++, $q++) {
            my $qnum = $qrynums[$q];
            ##skip if errors from the previous run are pending
            next if $$rinputs{"${qnum}_rcode"};
            $workers[$qnum] = threads->create(
                    {'context' => 'list'},
                    $subroutine_t, 
                    $nopro, $norun, $ncpus, $qnum, $roptionkeys, $roptionvalues, $rinputs
            );
            unless($workers[$qnum]) {
                $$rinputs{"${qnum}_rcode"} = 1;##code of fail
                $$rinputs{"${qnum}_error"} = "Creation of thread $qnum (input $qnum) failed.\n";##error message
                $$rinputs{"${qnum}_errhl"} = "Creation of thread $qnum (input $qnum) failed.\n";##high-level msg
            }
            ##print(STDERR "[test] --> w= $w q= $q\n");
        }

        @joinable = threads->list(threads::joinable);##...or use @workers

        foreach my $thr(@joinable) {
            my @thretlst = $thr->join();
            my $qnum = $thretlst[0];
            if($#qrynums < $qnum) {
                $$rerrmsg = "ERROR: $MYPROGNAME: 
                    Invalid query/input number returned by thread ".$thr->tid().".\n";
                $$rhlerrmsg = '';##not to be shown
                $ret = 0;
                next;
            }
            $$rinputs{"${qnum}_rcode"} = $thretlst[1];##code of fail
            $$rinputs{"${qnum}_error"} = $thretlst[2];##error message
            $$rinputs{"${qnum}_errhl"} = $thretlst[3];##high-level msg
            $$rinputs{"${qnum}_msafl"} = $thretlst[4] if $thretlst[4];##MSA filename
            $$rinputs{"${qnum}_profl"} = $thretlst[5] if $thretlst[5];##profile filename
            $tmMSA += ($$rinputs{"${qnum}_tmMSA"} = $thretlst[6]);##MSA building timespan
            $tmPro += ($$rinputs{"${qnum}_tmPro"} = $thretlst[7]);##profile construction timespan
            $$rinputs{"${qnum}_hhsrun"} = $thretlst[8] if $thretlst[8];##whether hhsuite has been run
            $$rinputs{"${qnum}_hmmrun"} = $thretlst[9] if $thretlst[9];##whether hmmer has been run

            ##next if $$rinputs{"${qnum}_rcode"};
            do{$nvalidqries--; next} if $$rinputs{"${qnum}_rcode"};

            $nsuccess++;

            next if $procd == int($nsuccess*10/$nvalidqries);

            $procd = int($nsuccess*10/$nvalidqries);

            my $tmdmsg = '';
            if($tmMSA && $tmPro) {
                $tmdmsg = sprintf("(time distr.: %.0f%% MSA, %.0f%% profile construction)",
                        $tmMSA*100./($tmMSA+$tmPro),$tmPro*100./($tmMSA+$tmPro));
            } elsif($tmMSA) {
                $tmdmsg = sprintf("(time distr.: %.0f%% MSA)", $tmMSA*100./($tmMSA+$tmPro));
            } elsif($tmPro) {
                $tmdmsg = sprintf("(time distr.: %.0f%% profile construction)", $tmPro*100./($tmMSA+$tmPro));
            }

            ProgressMsg("  $nsuccess/$nqries queries done $tmdmsg\n");
        }

        sleep(2) if $#joinable < 0;
    }


    return $ret;
}

## -----------------------------------------------------------------------------
##
##
sub ProcessQuery_hhsuite_t
{
    my  $nopro = shift;##unused flag
    my  $norun = shift;##unsed flag
    my  $ncpus = shift;##number of cpus
    my  $qrynum = shift;##query serial number
    my  $roptionkeys_t = shift;##ref to the keys of options
    my  $roptionvalues_t = shift;## ref to the values of options
    my  $rinputs_t = shift;##ref to the hash of individual inputs

    my  $mysubname = (caller(0))[3];
    my  $preamb = "[ ${mysubname} ".threads->tid()." ] ";
    my  $rcode = 0;
    ## These are general return fields that should be returned even if not computed!
    ## error strings, output MSA and profile filenames, time for building the MSA, 
    ##   time for profile construction, and flags of hhsuite and hmmer having run:
    my ($error,$errhl,$msafile,$profile,$timeMSA,$timePro,$hhsrun,$hmmrun) = ('','','','',0,0,0,0);

    my  $combine = $$roptionvalues_t{$$roptionkeys_t{hhsuite_in_use}} &&
                   $$roptionvalues_t{$$roptionkeys_t{hmmer_in_use}};

    ## use these contants over all thread subprograms:
    my ($resfxhhs) = ('_resulthhs');
    my  $inputfile = $$rinputs_t{"${qrynum}_input"};
    my  $outputreformatfile = $$rinputs_t{"${qrynum}_bname"}."_rfm.${AFAEXT}";
    my  $outputhhsfile = $$rinputs_t{"${qrynum}_bname"}.${resfxhhs};
    my  $logfile = $$rinputs_t{"${qrynum}_logfl"};
    my  $inputiscomerpro = ($inputfile =~ /$PROEXT$/)? 1: 0;
    my  $inputisa3m = ($inputfile =~ /$A3MEXT$/)? 1: 0;
    my  $opta = $combine? '': '-a';
    my  $command = '';

    $hhsrun = $$rinputs_t{"${qrynum}_hhsrun"};
    $hmmrun = $$rinputs_t{"${qrynum}_hmmrun"};

    if($$roptionvalues_t{$$roptionkeys_t{hhsuite_in_use}} && !$inputiscomerpro) {
        $timeMSA = time();

        my $hhinputfile = $inputfile;

        if($inputisa3m) {
            my $tmpfile = "${outputreformatfile}.f";
            $command = "$$roptionvalues_t{prog_hhsuite_reformat} a3m fas \"${inputfile}\" \"${tmpfile}\" && ".
                "(perl -e 'while(<>){\$d=1 if /^>/; \$d=0 if /^>ss_/;print if \$d}' ${tmpfile} >${outputreformatfile})";
            ##$command = "$$roptionvalues_t{prog_hhsuite_reformat} a3m fas \"${inputfile}\" \"${outputreformatfile}\"";

            unless(-f $outputreformatfile) {
                if(open(F,'>>',$logfile)){print(F GetTime()."${preamb} ${command}\n\n");close(F);}

                unless(ExecCommand($command)) {
                    $error = "ERROR: $MYPROGNAME: $preamb Failed to reformat MSA No.${qrynum}: '${inputfile}'\n";
                    $errhl = "Reformatting the MSA (query No.${qrynum}) failed. Please check your input.\n";
                    return ($qrynum, 1, $error, $errhl, $msafile, $profile, time()-$timeMSA, $timePro, $hhsrun, $hmmrun);
                }
            }

            $hhinputfile = $outputreformatfile;
        }

        $command = "${HHBLITShelper} -i \"${hhinputfile}\" -o \"${outputhhsfile}\" -d \"".
                $$roptionvalues_t{$$roptionkeys_t{hhsuite_db}}."\" -n ".
                $$roptionvalues_t{$$roptionkeys_t{hhsuite_opt_niterations}}." -e ".
                $$roptionvalues_t{$$roptionkeys_t{hhsuite_opt_evalue}}." -p ${ncpus} ${opta} -b \"".
                $cfgvar->InstallDir_HHsuite()."\" -N ${MAXNSEQS_perprog} >>\"${logfile}\" 2>&1";

        my $condfile = $combine? "${outputhhsfile}.${PWFEXT}": "${outputhhsfile}.${AFAEXT}";

        unless($hhsrun || -f $condfile) {
            if(open(F,'>>',$logfile)){print(F GetTime()."${preamb} ${command}\n\n");close(F);}

            unless(ExecCommand($command)) {
                $error = "ERROR: $MYPROGNAME: $preamb Failed to make MSA No.${qrynum} by hhsuite for '${inputfile}'\n";
                $errhl = "Building an MSA by searching for query No.${qrynum} failed. Please check your input.\n";
                return ($qrynum, 1, $error, $errhl, $msafile, $profile, time()-$timeMSA, $timePro, $hhsrun, $hmmrun);
            }
            $hhsrun = 1;
        }

        $msafile = $condfile;
        $timeMSA = time()-$timeMSA;
    }

    return ($qrynum, $rcode, $error, $errhl, $msafile, $profile, $timeMSA, $timePro, $hhsrun, $hmmrun);
}

## -----------------------------------------------------------------------------
## TODO: Modularize!
##
sub ProcessQuery_t
{
    my  $nopro = shift;##flag of no construction of COMER profiles
    my  $norun = shift;##flag of no COMER run
    my  $ncpus = shift;##number of cpus
    my  $qrynum = shift;##query serial number
    my  $roptionkeys_t = shift;##ref to the keys of options
    my  $roptionvalues_t = shift;## ref to the values of options
    my  $rinputs_t = shift;##ref to the hash of individual inputs

    my  $mysubname = (caller(0))[3];
    my  $preamb = "[ ${mysubname} ".threads->tid()." ] ";
    my  $rcode = 0;
    ## These are general return fields that should be returned even if not computed!
    ## error strings, output MSA and profile filenames, time for building the MSA, 
    ##   time for profile construction, and flags of hhsuite and hmmer having run:
    my ($error,$errhl,$msafile,$profile,$timeMSA,$timePro,$hhsrun,$hmmrun) = ('','','','',0,0,0,0);

    my  $search = $$roptionvalues_t{$$roptionkeys_t{hhsuite_in_use}} ||
                  $$roptionvalues_t{$$roptionkeys_t{hmmer_in_use}};
    my  $combine = $$roptionvalues_t{$$roptionkeys_t{hhsuite_in_use}} &&
                   $$roptionvalues_t{$$roptionkeys_t{hmmer_in_use}};

    my ($resfxhhs,$resfxhmm,$resfx) = ('_resulthhs','_resulthmmer','_result');
    my  $inputfile = $$rinputs_t{"${qrynum}_input"};
    my  $outputreformatfile = $$rinputs_t{"${qrynum}_bname"}."_rfm.${AFAEXT}";
    my  $rfminputfile = $inputfile;
    my  $outputhhsfile = $$rinputs_t{"${qrynum}_bname"}.${resfxhhs};
    my  $outputhmmfile = $$rinputs_t{"${qrynum}_bname"}.${resfxhmm};
    my  $reshhspwfafile = "${outputhhsfile}.${PWFEXT}";
    my  $reshmmpwfafile = "${outputhmmfile}.${PWFEXT}";
    my  $logfile = $$rinputs_t{"${qrynum}_logfl"};
    my  $opta = $combine? '': '-a';
    my  $respwfafile = $$rinputs_t{"${qrynum}_bname"}."${resfx}.${PWFEXT}";
    my  $resfilepat = $$rinputs_t{"${qrynum}_bname"}.${resfx};##pattern of result files
    my  $resafafile = "${resfilepat}.${AFAEXT}";##resulting MSA file
    my  $resprofile = "${resfilepat}.${PROEXT}";##profile name
    my  $resqryfile = '';##query filename
    my  $inputiscomerpro = ($inputfile =~ /$PROEXT$/)? 1: 0;
    my  $inputisa3m = ($inputfile =~ /$A3MEXT$/)? 1: 0;
    my ($command, $cmbcmd) = ('','');

    $hhsrun = $$rinputs_t{"${qrynum}_hhsrun"};
    $hmmrun = $$rinputs_t{"${qrynum}_hmmrun"};


    if($inputisa3m) {
        my $tmpfile = "${outputreformatfile}.f";
        $command = "$$roptionvalues_t{prog_hhsuite_reformat} a3m fas \"${inputfile}\" \"${tmpfile}\" &&".
            "(perl -e 'while(<>){\$d=1 if /^>/; \$d=0 if /^>ss_/;print if \$d}' ${tmpfile} >${outputreformatfile})";

        unless(-f $outputreformatfile) {
            if(open(F,'>>',$logfile)){print(F GetTime()."${preamb} ${command}\n\n");close(F);}

            unless(ExecCommand($command)) {
                $error = "ERROR: $MYPROGNAME: $preamb Failed to reformat MSA No.${qrynum}: '${inputfile}'\n";
                $errhl = "Reformatting the MSA (query No.${qrynum}) failed. Please check your input.\n";
                return ($qrynum, 1, $error, $errhl, $msafile, $profile, time()-$timeMSA, $timePro, $hhsrun, $hmmrun);
            }
        }

        $rfminputfile = $outputreformatfile;
    }


    if($search && !$inputiscomerpro)
    {
        $timeMSA = time();

        if($$roptionvalues_t{$$roptionkeys_t{hhsuite_in_use}}) {
            $command = "${HHBLITShelper} -i \"${rfminputfile}\" -o \"${outputhhsfile}\" -d \"".
                    $$roptionvalues_t{$$roptionkeys_t{hhsuite_db}}."\" -n ".
                    $$roptionvalues_t{$$roptionkeys_t{hhsuite_opt_niterations}}." -e ".
                    $$roptionvalues_t{$$roptionkeys_t{hhsuite_opt_evalue}}." -p ${ncpus} ${opta} -b \"".
                    $cfgvar->InstallDir_HHsuite()."\" -N ${MAXNSEQS_perprog} >>\"${logfile}\" 2>&1";

            my $condfile = $combine? "${outputhhsfile}.${PWFEXT}": "${outputhhsfile}.${AFAEXT}";

            unless($hhsrun || -f $condfile) {
                if(open(F,'>>',$logfile)){print(F GetTime()."${preamb} ${command}\n\n");close(F);}

                unless(ExecCommand($command)) {
                    $error = "ERROR: $MYPROGNAME: $preamb Failed to make MSA No.${qrynum} by hhsuite for '${inputfile}'\n";
                    $errhl = "Building an MSA by searching for query No.${qrynum} failed. Please check your input.\n";
                    return ($qrynum, 1, $error, $errhl, $msafile, $profile, time()-$timeMSA, $timePro, $hhsrun, $hmmrun);
                }
                $hhsrun = 1;
            }

            $resqryfile = "${outputhhsfile}.${QRYEXT}";
            $resfilepat =  ${outputhhsfile};
            $resafafile = "${outputhhsfile}.${AFAEXT}";
            $cmbcmd .= " \"${outputhhsfile}.${PWFEXT}\"";
        }

        if($$roptionvalues_t{$$roptionkeys_t{hmmer_in_use}}) {
            $command = "${HMMERhelper} -i \"${rfminputfile}\" -o \"${outputhmmfile}\" -d \"".
                    $$roptionvalues_t{$$roptionkeys_t{sequence_db}}."\" -n ".
                    $$roptionvalues_t{$$roptionkeys_t{hmmer_opt_niterations}}." -e ".
                    $$roptionvalues_t{$$roptionkeys_t{hmmer_opt_evalue}}." -p ${ncpus} ${opta} -b \"".
                    $cfgvar->InstallDir_HMMER()."\" -N ${MAXNSEQS_perprog} >>\"${logfile}\" 2>&1";

            my $condfile = $combine? "${outputhmmfile}.${PWFEXT}": "${outputhmmfile}.${AFAEXT}";

            unless($hmmrun || -f $condfile) {
                if(open(F,'>>',$logfile)){print(F GetTime()."${preamb} ${command}\n\n");close(F);}

                unless(ExecCommand($command)) {
                    $error = "ERROR: $MYPROGNAME: $preamb Failed to make MSA No.${qrynum} by HMMER for '${inputfile}'\n";
                    $errhl = "Building an MSA by searching for query No.${qrynum} failed. Please check your input.\n";
                    return ($qrynum, 1, $error, $errhl, $msafile, $profile, time()-$timeMSA, $timePro, $hhsrun, $hmmrun);
                }
                $hmmrun = 1;
            }

            $resqryfile = "${outputhmmfile}.${QRYEXT}";
            $resfilepat =  ${outputhmmfile};
            $resafafile = "${outputhmmfile}.${AFAEXT}";
            $cmbcmd .= " \"${outputhmmfile}.${PWFEXT}\"";
        }

        if($combine) {
            $resfilepat = $$rinputs_t{"${qrynum}_bname"}.${resfx};
            $resafafile = "${resfilepat}.${AFAEXT}";
        }

        $msafile = $resafafile;

        if($combine && !-f "${resfilepat}.${AFAEXT}") {
            $resfilepat = $$rinputs_t{"${qrynum}_bname"}.${resfx};
            $resafafile = "${resfilepat}.${AFAEXT}";

            my $evalue = $$roptionvalues_t{$$roptionkeys_t{hhsuite_opt_evalue}};
            $evalue = $$roptionvalues_t{$$roptionkeys_t{hmmer_opt_evalue}}
                    if($evalue < $$roptionvalues_t{$$roptionkeys_t{hmmer_opt_evalue}});

            $command = "cat ${cmbcmd} >\"${respwfafile}\" 2>>\"${logfile}\"";

            if(open(F,'>>',$logfile)){print(F GetTime()."${preamb} ${command}\n\n");close(F);}

            unless(ExecCommand($command)) {
                $error = "ERROR: $MYPROGNAME: $preamb Failed to combine MSAs for query No.${qrynum}: '${inputfile}'\n";
                $errhl = "Combining MSAs obtained for query No.${qrynum} failed.\n";
                return ($qrynum, 1, $error, $errhl, $msafile, $profile, time()-$timeMSA, $timePro, $hhsrun, $hmmrun);
            }

            ##no matter which $resqryfile (by hhs or hmmer)
            $command = "${PWFA2MSAprog} -i \"${respwfafile}\" -o \"${resafafile}\" -f 0 ".
                    "-q \"${resqryfile}\" -e ${evalue} ".
                    "-N ".($MAXNSEQS_perprog*2)." >>\"${logfile}\" 2>&1";##x2 to account for two search programs
 
            if(open(F,'>>',$logfile)){print(F GetTime()."${preamb} ${command}\n\n");close(F);}

            unless(ExecCommand($command)) {
                $error = "ERROR: $MYPROGNAME: $preamb Failed to convert combined MSAs for query No.${qrynum}: '${inputfile}'\n";
                $errhl = "Combining MSAs obtained for query No.${qrynum} failed.\n";
                return ($qrynum, 1, $error, $errhl, $msafile, $profile, time()-$timeMSA, $timePro, $hhsrun, $hmmrun);
            }
        }

        $timeMSA = time()-$timeMSA;
    }


    if($inputiscomerpro) {
        $profile = $resprofile;
        unless(ChangeProfileFileField($inputfile, $profile, basename($inputfile))) {
            $error = "ERROR: $MYPROGNAME: $preamb Failed to preprocess profile No.${qrynum}: '${inputfile}'\n";
            $errhl = "Profile preprocessing for query No.${qrynum} failed. Please check your input.\n";
            return ($qrynum, 1, $error, $errhl, $msafile, $profile, $timeMSA, $timePro, $hhsrun, $hmmrun);
        }
    }
    elsif(!$nopro)
    {
        $timePro = time();

        $msafile = $search? $resafafile: $rfminputfile;
        $profile = $resprofile;

        $command = "$$roptionvalues_t{prog_comer_makepro} ".
                "-v -i \"${msafile}\" -o \"${profile}\" -p \"${OPTFILENAME}\" -P \"".
                $cfgvar->InstallDir_PSIPRED()."\" -B \"".
                $cfgvar->InstallDir_BLAST()."\" >>\"${logfile}\" 2>&1";

        unless(-f $profile)
        {
            unless(-f $msafile) {
                $error = "ERROR: $MYPROGNAME: $preamb MSA file for profile construction not found '${msafile}'\n";
                $errhl = "An MSA file for profile construction not found.\n";
                return ($qrynum, 1, $error, $errhl, $msafile, $profile, $timeMSA, time()-$timePro, $hhsrun, $hmmrun);
            }

            if(open(F,'>>',$logfile)){print(F GetTime()."${preamb} ${command}\n\n");close(F);}

            unless(ExecCommand($command)) {
                $error = "ERROR: $MYPROGNAME: $preamb Failed to construct profile No.${qrynum} by makepro for '${msafile}'\n";
                $errhl = "Constructing a profile for query No.${qrynum} failed. Please check your input.\n";
                return ($qrynum, 1, $error, $errhl, $msafile, $profile, $timeMSA, time()-$timePro, $hhsrun, $hmmrun);
            }
        }

        $timePro = time()-$timePro;
    }

    return ($qrynum, $rcode, $error, $errhl, $msafile, $profile, $timeMSA, $timePro, $hhsrun, $hmmrun);
}

## General =====================================================================
##
##







## =============================================================================
## MyExit: print a code to file and exit
##
sub MyExit
{
    my $ecode = shift;##exit code
    if(open(F,">>",$ERRFILENAME)){print(F "\n${ecode}\n");close(F);}
    exit($ecode);
}

## -------------------------------------------------------------------
## Warning: output a warning message and optionally, send an email
##
sub Warning
{
    my ($msg, $hlerrmsg, $nosend) = @_;
    return Issue($msg, $hlerrmsg, $nosend,
        '',
        "Warning from comer-ws ($MYPROGNAME)");
}

## Error: output an error message and optionally, send an email
##
sub Error
{
    my ($msg, $hlerrmsg, $nosend) = @_;
    return Issue($msg, $hlerrmsg, $nosend,
        "ERROR: Issue on the server's backend side: ",
        "Error message from comer-ws ($MYPROGNAME)");
}

## Issue: output an issue message and send an email
##
sub Issue
{
    my ($msg, $hlerrmsg, $nosend,  $leadtxt1, $sbjct) = @_;
    print(STDERR GetTime().$msg);
    if($ERRFILENAME && $hlerrmsg) {
        if(open(EF,">>",$ERRFILENAME)) {
            print(EF $leadtxt1.$hlerrmsg);
            close(EF);
        } else {
            print(STDERR "ERROR: $MYPROGNAME: Write to error file skipped ".
                "due to the fail to open the file: '$ERRFILENAME'\n");
        }
    }
    return 1 if $nosend;
    unless(-f $SENDMAILprog) {
        print(STDERR "ERROR: $MYPROGNAME: Send-mail program not found: $SENDMAILprog\n");
        return 0;
    }
    my  $command = "$SENDMAILprog --sub \"$sbjct\" --body \"$msg\" 2>&1";
    print(STDERR "$command\n");
    return ExecCommand($command);
}

## -------------------------------------------------------------------
## try read lock files in a directory and return 1 if locks exist,
## 0 otherwise, -1 on error
##

sub ReadLocks
{
    return ReadFiles( shift, shift );
}

sub ReadFiles
{
    my  $dirname = shift;
    my  $pattern = shift;  ## pattern of files to look for as locks
    my  $reffiles = shift; ## reference to vector of files
    my  @files;
    my  $locref = defined( $reffiles )? $reffiles: \@files;

    unless( opendir( DIR, $dirname )) {
        printf( STDERR "ERROR: Cannot open directory $dirname.\n" );
        return -1;
    }
    @{$locref} = grep { /$pattern$/ && -f File::Spec->catfile($dirname,$_) } readdir( DIR );
    closedir( DIR );
    return 1 if 0 <= $#{$locref};
    return 0;
}

## -------------------------------------------------------------------
## ExecCommand: execute system command
##
sub CheckStatus
{
    ExecCommand();
}

sub ExecCommand
{
    my  $cmdline = shift;
    my  $returnstatus = shift;##if defined, return exit status of the command

    system($cmdline) if $cmdline;

    if($? == -1) {
        print(STDERR GetTime()."ERROR: Failed to execute command: $!\n");
        return($returnstatus? 1: 0);
    }
    if($? & 127) {
        printf(STDERR GetTime()."ERROR: Command terminated with signal %d, %s coredump.\n",
            ($? & 127), ($? & 128)? 'with': 'without');
        return($returnstatus? ($? & 127): 0);
    }
    else {
        if(($? >> 8) != 0) {
            printf( STDERR GetTime()."ERROR: Command failed and exited with status %d\n",
                    $? >> 8);
            return($returnstatus? ($? >> 8): 0);
        }
    }
    return($returnstatus? 0: 1);
}

## <<>>

